# coding: utf8

import time
import datetime as dt
import pandas as pd
from abc import ABC


class TickData:
    """
    The TickData class represents a single unit of data received from a market data source.

    """

    def __init__(self, symbol, timestamp, last_price=0, total_volume=0):
        self.symbol = symbol
        self.timestamp = timestamp
        self.open_price = 0
        self.last_price = last_price
        self.total_volume = total_volume


class MarketData:
    """
    An instance of this class is used throughout the system to store and retrieve prices
    by the various components.

    """

    def __init__(self):
        self.__recent_ticks__ = dict()

    def add_last_price(self, time, symbol, price, volume):
        tick_data = TickData(symbol, time, price, volume)
        self.__recent_ticks__[symbol] = tick_data

    def add_open_price(self, time, symbol, price):
        tick_data = self.get_existing_tick_data(symbol, time)
        tick_data.open_price = price

    def get_existing_tick_data(self, symbol, time):
        if not symbol in self.__recent_ticks__:
            tick_data = TickData(symbol, time)
            self.__recent_ticks__[symbol] = tick_data
        return self.__recent_ticks__[symbol]

    def get_last_price(self, symbol):
        return self.__recent_ticks__[symbol].last_price

    def get_open_price(self, symbol):
        return self.__recent_ticks__[symbol].open_price

    def get_timestamp(self, symbol):
        return self.__recent_ticks__[symbol].timestamp


class MarketDataSource:
    def __init__(self):
        self.event_tick = None
        self.ticker, self.source = None, None
        self.start, self.end = None, None
        self.md = MarketData()


class Order:
    """
    The Order class represents a single order sent by the strategy to the server.
    Once an order is filled, the order is further updated with the filled time, quantity, and price.
    """

    def __init__(self, timestamp, symbol, qty, is_buy, is_market_order, price=0):
        self.timestamp = timestamp
        self.symbol = symbol
        self.qty = qty
        self.price = price
        self.is_buy = is_buy
        self.is_market_order = is_market_order
        self.is_fulled = False
        self.filled_price = 0
        self.filled_time = None
        self.fill_qty = 0


class Position:
    """
    The Position class helps us keep track of our current market position and account balance.
    """

    def __init__(self, symbol):
        self.symbol = symbol
        self.buys, self.sells, self.net = 0, 0, 0
        self.realized_pnl = 0
        self.unrealized_pnl = 0
        self.position_value = 0

    def event_fill(self, timestamp, is_buy, qty, price):
        if is_buy:
            self.buys += qty
        else:
            self.sells += qty

        self.net = self.buys - self.sells
        changed_value = qty * price * (-1 if is_buy else 1)
        self.position_value += changed_value

        if self.net == 0:
            self.realized_pnl = self.position_value

    def update_unrealized_pnl(self, price):
        if self.net == 0:
            self.unrealized_pnl = 0
        else:
            self.unrealized_pnl = price * self.net + self.position_value
        return self.unrealized_pnl


class Strategy(ABC):
    """
    The Strategy class is the base class for all other strategy implementations.

    The event_tick method is called when new market tick data arrives.

    The event_order method is called whenever there are order updates.

    The event_position method is called whenever there are updates to our positions.

    The send_market_order method is called when the implementing strategy sends a market order to the host
    component to be routed to the server for execution:
    """

    def __init__(self, symbol, event_sendorder):
        self.symbol = symbol
        self.event_sendorder = event_sendorder

    def event_tick(self, market_data):
        pass

    def event_order(self, order):
        pass

    def event_position(self, positions):
        pass

    def send_market_order(self, symbol, qty, is_buy, timestamp):
        if not self.event_sendorder is None:
            order = Order(timestamp, symbol, qty, is_buy, True)
            self.event_sendorder(order)


class Backtester:
    """
    A simple event-driven backtesting engine
    """

    def __init__(self, symbol, stragegy_class, data_source: pd.DataFrame):
        self.target_symbol = symbol
        self.strategy = stragegy_class(symbol, self._event_handler_order)
        self.data_source = data_source
        self.unfilled_orders = []
        self.positions = dict()
        self.current_prices = None
        self.rpnl, self.upnl = pd.DataFrame(), pd.DataFrame()

    @property
    def timestamp(self):
        return self.current_prices.get_timestamp(self.target_symbol)

    @property
    def trade_date(self):
        return self.timestamp.strftime("%Y-%m-%d")

    def get_position(self, symbol):
        if symbol not in self.positions:
            position = Position(symbol)
            self.positions[symbol] = position
        return self.positions[symbol]

    def _update_filled_position(self, symbol, qty, is_buy, price, timestamp):
        position = self.get_position(symbol)
        position.event_fill(timestamp, is_buy, qty, price)
        self.strategy.event_position(self.positions)
        self.rpnl.loc[timestamp, "rpnl"] = position.realized_pnl
        print(f"{self.trade_date}, {symbol}, Filled: {'BUY' if is_buy else 'SELL'}, Qty: {qty} at {price}")

    def _event_handler_order(self, order):
        self.unfilled_orders.append(order)
        print(f"{self.trade_date}, Received order: {'BUY' if order.is_buy else 'SELL'} {order.symbol}, Qty: {order.qty}")

    def _event_handler_tick(self, prices):
        self.current_prices = prices
        self.strategy.event_tick(prices)
        self._match_order_book(prices)
        self._print_position_status(self.target_symbol, prices)

    def _match_order_book(self, prices):
        if len(self.unfilled_orders) > 0:
            self.unfilled_orders = \
                [order for order in self.unfilled_orders if self._is_order_unmatched(order, prices)]

    def _is_order_unmatched(self, order, prices):
        symbol = order.symbol
        timestamp = prices.get_timestamp(symbol)

        if order.is_market_order and timestamp > order.timestamp:
            # Order is matched and filled
            order.is_filled = True
            open_price = prices.get_open_price(symbol)
            order.filled_time = timestamp
            order.filled_price = open_price
            self._update_filled_position(symbol, order.qty, order.is_buy, open_price, timestamp)
            self.strategy.event_order(order)
            return False

        return True

    def _print_position_status(self, symbol, prices):
        if symbol in self.positions:
            position = self.positions[symbol]
            close_price = prices.get_last_price(symbol)
            position.update_unrealized_pnl(close_price)
            self.upnl.loc[self.timestamp, "unpl"] = position.unrealized_pnl

            print(f"{self.trade_date}, Net: {position.net}, Value: {position.position_value}, \
                UPnL: {position.unrealized_pnl}, RPnL: {position.realized_pnl}")

    def start_backtest(self, start_date: dt.datetime, end_date: dt.datetime):
        data_view = self.data_source.loc[start_date: end_date, ["open", "close", "volume"]]
        market_data = MarketData()

        print("Backtesting started...")
        for time, row in data_view.iterrows():
            market_data.add_last_price(time, self.target_symbol, row["close"], row["volume"])
            market_data.add_open_price(time, self.target_symbol, row["open"])

            if not self._event_handler_tick is None:
                self._event_handler_tick(market_data)

        print("Backtesting completed.")


# coding: utf8

from backtest import Strategy
from backtest import Backtester

import pandas as pd
import datetime as dt


class MeanRevertingStrategy(Strategy):
    """
    Implementation of a mean-reverting strategy
    """

    def __init__(self, symbol, event_sendorder, 
            lookback_intervals=3, 
            buy_threshold=-1.5, 
            sell_threshold=1.5):
        super().__init__(symbol, event_sendorder)
        self.lookback_intervals = lookback_intervals
        self.buy_threshold = buy_threshold
        self.sell_threshold = sell_threshold
        self.prices = pd.DataFrame()
        self.is_long, self.is_short = False, False

    def event_position(self, positions):
        "updates the state of the strategy to indicate a long or a short on every change in position"
        if self.symbol in positions:
            position = positions[self.symbol]
            self.is_long = True if position.net > 0 else False
            self.is_short = True if position.net < 0 else False

    def event_tick(self, market_data):
        """perform the trade logic decision on every incoming tick data, 
        which is stored as a pandas DataFrame object, to calculate the strategy parameters"""
        self._store_prices(market_data)

        if len(self.prices) < self.lookback_intervals:
            return

        signal_value = self._calculate_z_score()
        timestamp = market_data.get_timestamp(self.symbol)

        if signal_value < self.buy_threshold:
            self._on_buy_signal(timestamp)
        elif signal_value > self.sell_threshold:
            self._on_sell_signal(timestamp)

    def _store_prices(self, market_data):
        timestamp = market_data.get_timestamp(self.symbol)
        self.prices.loc[timestamp, "close"] = \
            market_data.get_last_price(self.symbol)
        self.prices.loc[timestamp, "open"] = \
            market_data.get_open_price(self.symbol)

    def _calculate_z_score(self):
        "z_score = (x - Î¼) / sigma"
        self.prices = self.prices[-self.lookback_intervals:]
        returns = self.prices["close"].pct_change().dropna()
        z_score = ((returns - returns.mean())/returns.std())[-1]
        return z_score

    def _on_buy_signal(self, timestamp):
        if not self.is_long:
            self.send_market_order(self.symbol, 100, True, timestamp)

    def _on_sell_signal(self, timestamp):
        if not self.is_short:
            self.send_market_order(self.symbol, 100, False, timestamp)


if __name__ == "__main__":
    data_source = pd.DataFrame()
    backtester = Backtester("#603833.SH#", MeanRevertingStrategy, data_source)

    backtester.start_backtest(dt.datetime(2016, 1, 1), dt.datetime(2016, 12, 31))
